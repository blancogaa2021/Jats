f <- function(x, alpha, beta) {
beta(alpha, beta)^(-1) * x^(alpha-1) * (1-x)^(beta-1)
}
integrate(f, 0, 1, alpha = .5, beta = .5)
integrate(f, 0, 1, alpha = .001, beta = .001)
integrate(f, 0, 1, alpha = .0008, beta = .0008)
integrate(f, 0, 1, alpha = .0001, beta = .0001)
rm(list=ls())
f <- function(x, alpha, beta) {
beta(alpha, beta)^(-1) * x^(alpha-1) * (1-x)^(beta-1)
}
integrate(f, 0, 1, alpha = .5, beta = .5)
integrate(f, 0, 1, alpha = .001, beta = .001)
integrate(f, 0, 1, alpha = .0008, beta = .0008)
integrate(f, 0, 1, alpha = .0001, beta = .0001)
beta(0.001, 0.001)
beta(0.0001, 0.0001)
rm(list=ls())
f <- function(x, alpha, beta) {
beta(alpha, beta)^(-1) * x^(alpha-1) * (1-x)^(beta-1)
}
integrate(f, 0, 1, alpha = .5, beta = .5)
integrate(f, 0, 1, alpha = .001, beta = .001)
integrate(f, 0, 1, alpha = .0008, beta = .0008)
integrate(f, 0, 1, alpha = .0001, beta = .0001)
f <- function(x, alpha, beta) {
beta(alpha, beta)^(-1) * x^(alpha-1) * (1-x)^(beta-1)
}
integrate(f, 0, 1, alpha = .5, beta = .5)
integrate(f, 0, 1, alpha = .001, beta = .001)
integrate(f, 0, 1, alpha = .0008, beta = .0008)
integrate(f, 0, 1, alpha = .0001, beta = .0001)
install.packages("blavaan")
library(blavaan)
data(StereotypeThreat, package="psychotools")
library(blavaan)
data(StereotypeThreat, package="psychotools")
install.packages("psychtools")
install.packages("psychotools")
library(blavaan)
data(StereotypeThreat, package="psychotools")
model <- ' verbal ~ numerical '
## regression with non-fixed x
fit <- bsem(model, data=StereotypeThreat, fixed.x=FALSE)
fit
dpriors()
fit <- bsem(model, data=StereotypeThreat, fixed.x=FALSE, jagfile=TRUE)
fit
getwd()
model <- '
# latent variable definitions
ind60 =~ x1 + x2 + x3
dem60 =~ y1 + a*y2 + b*y3 + c*y4
dem65 =~ y5 + a*y6 + b*y7 + c*y8
# regressions
dem60 ~ ind60
dem65 ~ ind60 + dem60
# residual correlations
y1 ~~ y5
y2 ~~ y4 + y6
y3 ~~ y7
y4 ~~ y8
y6 ~~ y8
'
jagcontrol=list(method="rjparallel"), jagfile=TRUE)
fit <- bsem(model, data=PoliticalDemocracy,
dp=dpriors(nu="dnorm(5,1e-2)", itheta="dlnorm(1,.1)[sd]",
ipsi="dlnorm(1,.1)[sd]", rho="dbeta(3,3)"),
jagcontrol=list(method="rjparallel"), jagfile=TRUE)
fit
fitMeasures(fit)
HS.model <- ' visual =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed =~ x7 + x8 + x9 '
fit1 <- cfa(HS.model, data = HolzingerSwineford1939, group = "school")
fit2 <- cfa(HS.model, data = HolzingerSwineford1939, group = "school",
group.equal = "loadings")
fit3 <- cfa(HS.model, data = HolzingerSwineford1939, group = "school",
group.equal = c("loadings", "intercepts"))
parTable(fit1)
bfit1 <- bcfa(parTable(fit1), data=HolzingerSwineford1939, group="school")
bfit2 <- bcfa(parTable(fit2), data=HolzingerSwineford1939, group="school")
bfit3 <- bcfa(parTable(fit3), data=HolzingerSwineford1939, group="school")
x <- matrix(c(1,2,3,4,5,6), 3, 2)
x
t(x) %*% x
1/2 * t(x) %*% x
cov(x)
z <- apply(x, 2, function(x) x-mean(x))
1/2 * t(z) %*% z
.bayesBinomialTest.twoSided <- function(counts, n, theta0, a, b) {
logBF10 <- lbeta(counts+a, n-counts+b) -  lbeta(a, b) - counts*log(theta0) - (n-counts)*log(1-theta0)
BF10 <- exp(logBF10)
return(BF10)
}
.bayesBinomialTest.twoSided(counts = 3, 5)
.bayesBinomialTest.twoSided(counts = 3, 5, .5, 1, 1)
.bayesBinomialTest.twoSided.jeffreys <- function(counts, n, theta0) {
# assuming a = b = 1, i.e., uniform prior
logBF01 <- lgamma(n + 2) - lgamma(counts + 1) - lgamma(n - counts + 1) + counts*log(theta0) + (n - counts)*log(1 - theta0)
BF10 <- 1 / exp(logBF01)
return(BF10)
}
.bayesBinomialTest.twoSided.jeffreys(3,5,.5)
.bayesBinomialTest.twoSided.jeffreys(2,5,.5)
counts <- 672
n <- 1372
BF10 <- .bayesBinomialTest.twoSided(counts, n, .5, 1, 1)
BFplus1 <- pbeta(.5, 1 + counts, 1 + n - counts, lower.tail = FALSE)/ .5
BFplus1 * BF10
BFplus1 <- pbeta(.5, 1 + counts, 1 + n - counts, lower.tail = TRUE)/ .5
BFplus1 * BF10
x1 <- c(1,2,3)
x2 <- c(1,4,1)
y <- c(3,6,1)
f <- lm(y~x1+x2)
summary(f)
residuals(f)
f <- lm(y~x1)
summary(f)
residuals(f)
t(residuals(f)) %*% resisuals(f)
t(residuals(f)) %*% residuals(f)
residuals(f)^2
sum(residuals(f)^2)
f <- lm(y~x1+x2)
summary(f)
x <- c(3,4,-1,2)
xs <- sort(x)
seq_along(xs)/length(x)
(seq_along(xs)-3/8)/(length(x)+1/4)
xp <- qnorm((seq_along(xs)-3/8)/(length(x)+1/4))
plot(xs, xp)
qqplot(x)
qqnorm(x)
points(xs, xp, col="red")
points(xp, xs, col="red")
qqnorm(x)
points(xp, xs, col="red")
qqnorm()
qqnorm
x <- c(3,4,-1,2)
x <- (x-mean(x))/sd(x)
xs <- sort(x)
xp <- qnorm((seq_along(xs)-3/8)/(length(x)+1/4))
qqnorm(x)
points(xp, xs, col="red")
x <- c(1,3,2)
y <- c(-1,0, -1)
f1 <- lm(y~x)
f2 <- lm(x~y)
summary(f1)
summary(f2)
x <- c(1,3,2)
x2 <- c(2,5,3)
x1 <- c(1,3,2)
x2 <- c(2,5,3)
plot(x1,x2)
prcomp(cbind(x1,x2))
pc <- prcomp(cbind(x1,x2))
summary(pc)
pc$x
points(pc$x[,1], pc$x[,2])
plot(pc$x[,1], pc$x[,2])
plot(x1,x2)
y <- c(-1,0, -1)
f1 <- lm(y~x1+x2)
f2 <- lm(y~pc$x[,1])
summary(f1)
summary(f2)
x1 <- c(1,3,2,3)
x2 <- c(2,5,3,3)
plot(x1,x2)
pc <- prcomp(cbind(x1,x2))
plot(pc$x[,1], pc$x[,2])
summary(pc)
pc$x
summary(pc)
y <- c(-1,0, -1)
f1 <- lm(y~x1+x2)
f2 <- lm(y~pc$x[,1])
y <- c(-1,0, -1, 2)
f1 <- lm(y~x1+x2)
f2 <- lm(y~pc$x[,1])
summary(f1)
summary(f2)
summary(pc)
x1 <- c(1,3,2,2)
x2 <- c(2,5,3,3)
plot(x1,x2)
pc <- prcomp(cbind(x1,x2))
plot(pc$x[,1], pc$x[,2])
summary(pc)
y <- c(-1,0, -1, 2)
f1 <- lm(y~x1+x2)
f2 <- lm(y~pc$x[,1])
summary(f1)
summary(f2)
f2 <- lm(y~pc$x[,1]+pc$x[,2])
summary(f1)
summary(f2)
summary(f1)
summary(f2)
cor(pc$x)
cor(cbind(x1,x2))
summary(pc)
f3 <- lm(y~pc$x[,1])
summary(f3)
plot(predicted(f1))
plot(predict(f1))
plot(predict(f2))
x1 <- runif(100)
x2 <- runif(100)*x1
plot(x1,x2)
pc <- prcomp(cbind(x1,x2))
plot(pc$x[,1], pc$x[,2])
cor(pc$x)
cor(cbind(x1,x2))
summary(pc)
y <- c(-1,0, -1, 2)
y <- runif(100)
f1 <- lm(y~x1+x2)
f2 <- lm(y~pc$x[,1]+pc$x[,2])
f3 <- lm(y~pc$x[,1])
plot(predict(f2))
summary(f1)
summary(f2)
summary(f3)
x1 <- runif(100)
x2 <- runif(100)*x1
x3 <- runif(100)*x1
f1 <- lm(y~x1+x2+x3)
f2 <- lm(y~pc$x[,1]+pc$x[,2])
f3 <- lm(y~pc$x[,1])
plot(predict(f2))
summary(f1)
summary(f2)
pc$x
pc <- prcomp(cbind(x1,x2,x3))
plot(pc$x[,1], pc$x[,2])
cor(pc$x)
cor(cbind(x1,x2))
summary(pc)
y <- runif(100)
f1 <- lm(y~x1+x2+x3)
f2 <- lm(y~pc$x[,1]+pc$x[,2])
f3 <- lm(y~pc$x[,1])
plot(predict(f2))
summary(f1)
summary(f2)
summary(f3)
VIF(f1)
Vif(f1)
vif(f1)
r <- cor(cbind(x1,x2))
r
eigen(r)
ev <- eigen(r)$values
evec <- eigen(r)$vectors
t(evec[,1]) %*% evec[,1]
evec[,1]
evec[,1] %*% t(evec[,1])
ev[1] * evec[,1] %*% t(evec[,1])
ev[1] * evec[,1] %*% t(evec[,1]) + ev[2] * evec[,2] %*% t(evec[,2])
r
.1/(.1+.1*.9)
(.1+.1*.9)
.1/(.1+.1*.99)
.1/(.001+.1*.999)
.001/(.001+.1*.999)
(.001+.1*.999)
rm(list = ls())
X <- matrix(rnorm(10*4), 10, 4)
X <- cbind(1, Y)
X <- matrix(rnorm(10*4), 10, 4)
X1 <- cbind(1, X)
Y <- matrix(rnorm(10,2), 10, 2)
lm(Y ~ X)
solve(t(X1)%*%X1) %*% t(X) %*% Y
solve(t(X1)%*%X1)
t(X)
solve(t(X1)%*%X1) %*% t(X1) %*% Y
lm(Y ~ X)
upperbound <- function(t, lambda, k = 1, aprime, a) {
a - pweibull(t, k, lambda) * (a/2 - aprime)
}
plot(function(x)upperbound(x, k = 5, lambda = 1, aprime = .1, a = .12, z = .12), xlim = c(0, 10), ylim = c(0, .2))
upperbound <- function(t, lambda, k = 1, aprime, z) {
a - pweibull(t, k, lambda) * (z - aprime)
}
plot(function(x)upperbound(x, k = 5, lambda = 1, aprime = .1, a = .12, z = .12), xlim = c(0, 10), ylim = c(0, .2))
upperbound <- function(t, lambda, k = 1, aprime, z, a) {
a - pweibull(t, k, lambda) * (z - aprime)
}
plot(function(x)upperbound(x, k = 5, lambda = 1, aprime = .1, a = .12, z = .12), xlim = c(0, 10), ylim = c(0, .2))
plot(function(x)upperbound(x, k = 5, lambda = 1, aprime = .12, a = .12, z = .12), xlim = c(0, 10), ylim = c(0, .2))
plot(function(x)upperbound(x, k = 5, lambda = 1, aprime = .12, a = .12, z = .11), xlim = c(0, 10), ylim = c(0, .2))
plot(function(x)upperbound(x, k = 5, lambda = 1, aprime = .12, a = .12, z = .0), xlim = c(0, 10), ylim = c(0, .2))
plot(function(x)upperbound(x, k = 5, lambda = 1, aprime = .12, a = .12, z = .12), xlim = c(0, 10), ylim = c(0, .2))
l <- list()
l[[1]] <- 2
l[[2]] <- c(1,2,3)
l
names(l)
names(l) <- c("a", "b")
l
sort(numeric(0))
numeric(0)[2]
diag(rep(1, 10))
diag(rep(1, 3))
I <- diag(rep(1, 3))
E <- matrix(c(1, .3, .3, 1), 2, 2)
W
E
kronecker(I, E)
rnorm(1)
rnorm(1)
rnorm(1)
rnorm(1)
rnorm(1)
rnorm(1)
set.seed(123)
rnorm(1)
rnorm(1)
rnorm(1)
set.seed(123)
rnorm(1)
rnorm(1)
rnorm(1)
set.seed(123)
rnorm(10)
set.seed(123)
rnorm(10)
rnorm(10)
set.seed(1244949)
rnorm(10)
set.seed(12)
rnorm(10)
exp(-.5*100)
exp(-.5*1000)
bic1 <- 100
bic2 <- 50
posteriorProb <- function(bic1, bic2) {
e <- as.brob(exp(1))
tmp <- e^(-.5*bic1) / (e^(-.5*bic1) + e^(-.5*bic2))
prob <- as.numeric(tmp)
return(prob)
}
posterior(bic1, bic2)
library(Brobdingnag)
posteriorProb <- function(bic1, bic2) {
e <- as.brob(exp(1))
tmp <- e^(-.5*bic1) / (e^(-.5*bic1) + e^(-.5*bic2))
prob <- as.numeric(tmp)
return(prob)
}
posterior(bic1, bic2)
posteriorProb(bic1, bic2)
bic1 <- 55
bic2 <- 50
library(Brobdingnag)
posteriorProb <- function(bic1, bic2) {
e <- as.brob(exp(1))
tmp <- e^(-.5*bic1) / (e^(-.5*bic1) + e^(-.5*bic2))
prob <- as.numeric(tmp)
return(prob)
}
posteriorProb(bic1, bic2)
exp(.5*(bic1-bic2)) / (1+exp(.5*(bic1-bic2)))
exp(.5*(bic2-bic1)) / (1+exp(.5*(bic2-bic1)))
setwd("~/Research Assisstant E.J/Replication Bayes Factors/Josine's Code")
source("Repfunctionspack.R")
### Elliot et al. (2010):  Red, rank and romance ###
# Original study: t value: 2.18, n1: 10, m1: 11
# 3 Replication studies: t values: 3.06,.25,2.44; n2: 27,27,16; m1: 27,27,17
# Independent JZS Bayes factors in Original and Replication studies, one and two sided:
# Replication Bayes factors: Is the effect the same as in the original study or zero?
# Bayarri and Mayoral Bayes Factor: is the replicated effect size equal to the original or different
# Meta-analysis Bayes factor: combining all effect sizes
BFelliot <- BFSALL(2.18,c(3.06,.25,2.44),10, c(27,27,16), 11, c(27,27,17), sample=2, Type = "ALL")
BFelliot
#####################################################################################
### Shanks et al. (2013) replicating Professor priming (LeBoeuff and Estes, 2004) ###
# original study: t values  tPS2, n1: 22 , m1: 22
#tPS <- sqrt(7.12) # Compute t value
tPS2 <- (56.2- 45.2) / (sqrt((20*11.1^2 + 22* 13^2)/ 42)  *  sqrt(1/21 + 1/23) )  # t-value computed form the reults table
# first replication study: -.25 - 25, 24
# the second  study should have effect size: t =  -1.25 p = .11 16 , 16
#If all are counted as replications of the same effec:
BFshanksall <-  BFSALL(tPS2,c(-.25, -1.25),22, c(25,16), 22,c(24,16),sample=2, Type="ALL")
BFshanksall
### Neill and Kahan (1999)  replicating Negative priming (Milliken et al., 1998) ###
# Original study: t value: 3.29, n1: 20
# 2 Replication studies: t values: 2.06,-2.4 n2: 30,43
BFNeill <-  BFSALL(3.29,c(2.06,-2.4), 20, c(30,43), Type = "ALL")
BFNeill
92/4
62/4
92/4
x <- rnorm(100,.5,1)
y <- rnorm(100,0,1)
# Make sure to input the vectors in the order of the original study.
#########################
#For a one sample t-test:
x <- rnorm(80,.5,1)
y <- rnorm(100,0,1)
# Make sure to input the vectors in the order of the original study.
#########################
#For a one sample t-test:
#########################
# For a one sample test:
trep <- t.test(x,y, paired = TRUE)$statistic
# for a two sample test:
x <- rnorm(20)
y <- rnorm(30)
trep <- t.test(x,y, paired = FALSE)$statistic
n2 <- length(x)
m2 <- length(y)
#Example data:
tobs <- 2  # t observed original study
n1 <- 50   # number of subjects in group 1 in the original study
m1 <- 50   # number of subjects in group 2 in the original study
sample  <- 2
# Independent JZS Bayes factors in Original and Replication studies, one and two sided:
# Replication Bayes factors: Is the effect the same as in the original study or zero?
# Bayarri and Mayoral Bayes Factor: is the replicated effect size equal to the original or different
# Meta-analysis Bayes factor: combining all effect sizes
BF <- BFSALL(tobs, trep, n1, n2, m1=m1,m2=m2, sample=sample, Type = "ALL")
BF
BF <- BFSALL(tobs, trep, n2, n1, m1=m1,m2=m2, sample=sample, Type = "ALL")
BF
source("Repfunctionspack.R")
x <- rnorm(90,.5,1)
y <- rnorm(100,0,1)
# for a two sample test:
trep <- t.test(x,y, paired = FALSE)$statistic
n2 <- length(x)
m2 <- length(y)
#Example data:
tobs <- 2  # t observed original study
n1 <- 50   # number of subjects in group 1 in the original study
x <- rnorm(100,.5,1)
y <- rnorm(100,0,1)
# for a two sample test:
trep <- t.test(x,y, paired = FALSE)$statistic
n2 <- length(x)
m2 <- length(y)
#Example data:
tobs <- 2  # t observed original study
n1 <- 50   # number of subjects in group 1 in the original study
m1 <- 50   # number of subjects in group 2 in the original study
sample  <- 2
BF <- BFSALL(tobs, trep, n1, n2, m1=m1,m2=m2, sample=sample, Type = "ALL")
BF
n1 <- 30   # number of subjects in group 1 in the original study
m1 <- 50   # number of subjects in group 2 in the original study
sample  <- 2
# Independent JZS Bayes factors in Original and Replication studies, one and two sided:
# Replication Bayes factors: Is the effect the same as in the original study or zero?
# Bayarri and Mayoral Bayes Factor: is the replicated effect size equal to the original or different
# Meta-analysis Bayes factor: combining all effect sizes
BF <- BFSALL(tobs, trep, n1, n2, m1=m1,m2=m2, sample=sample, Type = "ALL")
BF
BF <- BFSALL(tobs, trep, m1, n2, m1=n1,m2=m2, sample=sample, Type = "ALL")
BF
92/4
23/3
91/4
7+7
8+8
8+8+7
8*4+8*4+7*4
8*4+8*4
log(1-1)
.bayesBinomialTest.twoSided.jeffreys <- function(counts, n, theta0) {
# assuming a = b = 1, i.e., uniform prior
logBF01 <- lgamma(n + 2) - lgamma(counts + 1) - lgamma(n - counts + 1) + counts*log(theta0) + (n - counts)*log(1 - theta0)
BF10 <- 1 / exp(logBF01)
return(BF10)
}
.bayesBinomialTest.twoSided.jeffreys(10, 10, 1)
gamma(10+2)/gamma(10+1)
gamma(10+2)/(gamma(10+1)*gamma(10-10+1))
gamma(10+2)/(gamma(10+1)*gamma(10-10+1)) * 1^10 * 0
0^0
gamma(10+2)/(gamma(10+1)*gamma(10-10+1)) * 1^10 * 0^0
0*log(0)
0^10
0^0
1 <= 2
1 =>2
setwd("~/JASP/jasp-desktop/Resources/Data Sets")
d <- read.csv("Tooth Growth.csv", header = TRUE)
d <- read.csv("Tooth Growth.csv")
d
d[d$dose != "1000", ]
d1 <- d[d$dose != "1000", ]
t.test(len ~ dose, data = d1)
t.test(len ~ dose, data = d1, var.equal= TRUE)
d1 <- d[d$dose != "2000", ]
t.test(len ~ dose, data = d1, var.equal= TRUE)
23/3
7+7+8
8+8+7
8+8+7
8*4
32+32+28
pt(1.85, df = 89)
1-pt(1.85, df = 89)
1-pt(1.85, df = 60)
1-pt(1.85, df = 50)
1-pt(1.85, df = 10)
